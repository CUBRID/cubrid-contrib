/* DO NOT EDIT THIS FILE - it is machine generated */
#include "com_cubrid_validator_SQLValidator.h"

#include <jni.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

#include "dbi.h"
/* Header for class com_cubrid_validator_SQLValidator */

/* GLOBAL STATE */
#define DB_CONNECTION_STATUS_NOT_CONNECTED 0
#define DB_CONNECTION_STATUS_CONNECTED     1
#define DB_CONNECTION_STATUS_RESET        -1

#define NO_ERROR   0
#define ER_FAILED -1

#define DEFAULT_LIBRARY_PATH "C:\\CUBRID\\bin\\cubridcs.dll"
#define DEFAULT_LANG_CHARSET "ko_KR.utf8"
#define DEFAULT_BUF_LENGTH   1024

enum er_exit_ask {
	ER_NEVER_EXIT = 0,
	ER_EXIT_ASK = 1,
	ER_EXIT_DONT_ASK = 2,
	ER_ABORT = 3,
	ER_EXIT_DEFAULT = ER_NEVER_EXIT
};

typedef struct error_buf {
	char *buf;
	int length;
} ERROR_BUF;

typedef int (*fn_er_init)(const char *msglog_filename, int exit_ask);
typedef int (*fn_er_errid)();
typedef const char * (*fn_er_msg)();
typedef DB_SESSION_ERROR * (*fn_db_get_errors)(DB_SESSION * session);
typedef DB_SESSION_ERROR * (*fn_db_get_next_error)(DB_SESSION_ERROR * errors,
		int *line, int *col);
typedef int (*fn_lang_init)(); /* lang_Initialized */
typedef int (*fn_lang_set_charset_lang)(const char *lang_charset); /* lang_Language_initialized */
typedef void (*fn_db_set_connect_status)(int status);
typedef DB_SESSION * (*fn_db_open_buffer)(char * query);
typedef void (*fn_db_close_session)(DB_SESSION * session);

static fn_er_init cub_er_init = NULL;
static fn_er_errid cub_er_errid = NULL;
static fn_er_msg cub_er_msg = NULL;
static fn_db_get_errors cub_db_get_errors = NULL;
static fn_db_get_next_error cub_db_get_next_error = NULL;
static fn_lang_init cub_lang_init = NULL;
static fn_lang_set_charset_lang cub_lang_set_charset_lang = NULL;
static fn_db_set_connect_status cub_db_set_connect_status = NULL;
static fn_db_open_buffer cub_db_open_buffer = NULL;
static fn_db_close_session cub_db_close_session = NULL;

static int load(HINSTANCE hDLL, const char * libraryPath);
static int init(const char *lang_charset);
static int set_error(char ** error_buf, const char *er_msg);
static char * jstring_to_char(JNIEnv *env, jstring j_str);
static jstring char_to_jstring(JNIEnv *env, const char *str);

/*
 * Class:     com_cubrid_validator_SQLValidator
 * Method:    validateSQL
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_cubrid_validator_SQLValidator_validateSQL(
		JNIEnv *env, jobject j_obj, jstring j_str) {
	HINSTANCE hDLL = NULL;
	BOOL fFreeResult;
	char *query = NULL;
	DB_SESSION *session = NULL;
	DB_SESSION_ERROR *session_error = NULL;
	char *out_buf = NULL;
	int out_buf_len = 0;
	int out_buf_maxlen = 0;
	int has_error = 0;
	jstring result = NULL;

	if (load(hDLL, DEFAULT_LIBRARY_PATH) != NO_ERROR) {
		goto exit_on_error;
	}

	if (init(DEFAULT_LANG_CHARSET) != NO_ERROR) {
		goto exit_on_error;
	}

	query = jstring_to_char(env, j_str);
	if (query == NULL) {
		goto exit_on_error;
	}

	session = cub_db_open_buffer(query);
	if (session == NULL) {
		fprintf(stderr, "Failed to db_open_buffer().\n");
		fprintf(stderr, "%s\n", cub_er_msg());
		goto exit_on_error;
	}

	session_error = cub_db_get_errors(session);
	do {
		int line = 0, col = 0;
		int len = 0;
		int error = NO_ERROR;
		const char *er_msg = NULL;

		session_error = cub_db_get_next_error(session_error, &line, &col);

		error = cub_er_errid();
		if (error != NO_ERROR) {
			has_error = 1;

			er_msg = cub_er_msg();

			len = snprintf(NULL, 0, "In line %d, column %d,\n\nERROR(%d): %s\n",
					line, col, error, er_msg);

			if (out_buf == NULL) {
				out_buf = malloc(sizeof(char) * DEFAULT_BUF_LENGTH);
				if (out_buf == NULL) {
					fprintf(stderr, "Failed to allocate memory.\n");
					goto exit_on_error;
				}

				out_buf_len = 0;
				out_buf_maxlen = DEFAULT_BUF_LENGTH;

				snprintf(out_buf, len,
						"In line %d, column %d,\n\nERROR(%d): %s\n", line, col,
						error, er_msg);
				out_buf_len += len;
			} else {
				if (out_buf_len + len > out_buf_maxlen) {
					out_buf = realloc(out_buf,
							sizeof(char)
									* (out_buf_maxlen + DEFAULT_BUF_LENGTH));
					if (out_buf == NULL) {
						fprintf(stderr, "Failed to allocate memory.\n");
						goto exit_on_error;
					}

					out_buf_maxlen += DEFAULT_BUF_LENGTH;
				}

				snprintf(out_buf + out_buf_len - 1, len,
						"In line %d, column %d,\n\nERROR(%d): %s\n", line, col,
						error, er_msg);
				out_buf_len += len;
			}
		}
	} while (session_error != NULL);

	free(query);
	query = NULL;

	cub_db_close_session(session);
	session = NULL;

	if (hDLL != NULL) {
		FreeLibrary(hDLL);
		hDLL = NULL;
	}

	if (has_error) {
		result = char_to_jstring(env, out_buf);
	} else {
		result = char_to_jstring(env, "NO_ERROR");
	}

	exit_on_error:

	if (query != NULL) {
		free(query);
		query = NULL;
	}

	if (out_buf != NULL) {
		free(out_buf);
		out_buf = NULL;
		out_buf_len = 0;
		out_buf_maxlen = 0;
	}

	if (session != NULL) {
		cub_db_close_session(session);
		session = NULL;
	}

	if (hDLL != NULL) {
		FreeLibrary(hDLL);
		hDLL = NULL;
	}

	return result;
}

static int load(HINSTANCE hDLL, const char * libraryPath) {
	char *er_msg = NULL;

	hDLL = LoadLibrary(libraryPath);
	if (hDLL == NULL) {
		fprintf(stderr, "Failed to LoadLibrary().\n");
		return ER_FAILED;
	}

	cub_er_init = (fn_er_init) GetProcAddress(hDLL, "er_init");
	if (cub_er_init == NULL) {
		fprintf(stderr, "Failed to GetProcAddress(er_init).\n");
		return ER_FAILED;
	}

	cub_er_errid = (fn_er_errid) GetProcAddress(hDLL, "er_errid");
	if (cub_er_errid == NULL) {
		fprintf(stderr, "Failed to GetProcAddress(er_errid).\n");
		return ER_FAILED;
	}

	cub_er_msg = (fn_er_msg) GetProcAddress(hDLL, "er_msg");
	if (cub_er_msg == NULL) {
		fprintf(stderr, "Failed to GetProcAddress(er_msg).\n");
		return ER_FAILED;
	}

	cub_db_get_errors = (fn_db_get_errors) GetProcAddress(hDLL,
			"db_get_errors");
	if (cub_db_get_errors == NULL) {
		fprintf(stderr, "Failed to GetProcAddress(db_get_errors).\n");
		return ER_FAILED;
	}

	cub_db_get_next_error = (fn_db_get_next_error) GetProcAddress(hDLL,
			"db_get_next_error");
	if (cub_db_get_next_error == NULL) {
		fprintf(stderr, "Failed to GetProcAddress(db_get_next_error).\n");
		return ER_FAILED;
	}

	cub_lang_init = (fn_lang_init) GetProcAddress(hDLL, "lang_init");
	if (cub_lang_init == NULL) {
		fprintf(stderr, "Failed to GetProcAddress(lang_init).\n");
		return ER_FAILED;
	}

	cub_lang_set_charset_lang = (fn_lang_set_charset_lang) GetProcAddress(hDLL,
			"lang_set_charset_lang");
	if (cub_lang_set_charset_lang == NULL) {
		fprintf(stderr, "Failed to GetProcAddress(lang_set_charset_lang).\n");
		return ER_FAILED;
	}

	/* dumpbin -exports cubridcs.dll | findstr db_open_buffer_local */
	cub_db_set_connect_status = (fn_db_set_connect_status) GetProcAddress(hDLL,
			"db_set_connect_status");
	if (cub_db_set_connect_status == NULL) {
		fprintf(stderr, "Failed to GetProcAddress(db_set_connect_status).\n");
		return ER_FAILED;
	}

	cub_db_open_buffer = (fn_db_open_buffer) GetProcAddress(hDLL,
			"db_open_buffer");
	if (cub_db_open_buffer == NULL) {
		fprintf(stderr, "Failed to GetProcAddress(db_open_buffer).\n");
		return ER_FAILED;
	}

	cub_db_close_session = (fn_db_close_session) GetProcAddress(hDLL,
			"db_close_session");
	if (cub_db_close_session == NULL) {
		fprintf(stderr, "Failed to GetProcAddress(db_close_session).\n");
		return ER_FAILED;
	}

	return NO_ERROR;
}

static int init(const char *lang_charset) {
	if (cub_er_init(NULL, ER_NEVER_EXIT) != NO_ERROR) {
		fprintf(stderr, "Failed to initialize error manager.\n");
		return ER_FAILED;
	}

	if (cub_lang_init() != NO_ERROR) {
		fprintf(stderr, "Failed to initialize language module.\n");
		return ER_FAILED;
	}

	if (cub_lang_set_charset_lang(lang_charset) != NO_ERROR) {
		fprintf(stderr, "Failed to initialize language module.\n");
		return ER_FAILED;
	}

	cub_db_set_connect_status(DB_CONNECTION_STATUS_CONNECTED);

	return NO_ERROR;
}

static char * jstring_to_char(JNIEnv *env, jstring j_str) {
	const char *str = NULL;
	char *buf = NULL;

	if (j_str == NULL) {
		return NULL;
	}

	str = (*env)->GetStringUTFChars(env, j_str, NULL);
	buf = strdup(str);
	(*env)->ReleaseStringUTFChars(env, j_str, str);

	return buf;
}

static jstring char_to_jstring(JNIEnv *env, const char *str) {
	if (str == NULL) {
		return NULL;
	}

	return (*env)->NewStringUTF(env, str);
}
